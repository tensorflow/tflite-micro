// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_METADATA_TFLITE_MICRO_COMPRESSION_H_
#define FLATBUFFERS_GENERATED_METADATA_TFLITE_MICRO_COMPRESSION_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace tflite {
namespace micro {
namespace compression {

struct Metadata;
struct MetadataBuilder;
struct MetadataT;

struct Subgraph;
struct SubgraphBuilder;
struct SubgraphT;

struct LutTensor;
struct LutTensorBuilder;
struct LutTensorT;

struct MetadataT : public ::flatbuffers::NativeTable {
  typedef Metadata TableType;
  uint32_t schema_version = 1;
  std::vector<std::unique_ptr<tflite::micro::compression::SubgraphT>> subgraphs{};
  MetadataT() = default;
  MetadataT(const MetadataT &o);
  MetadataT(MetadataT&&) FLATBUFFERS_NOEXCEPT = default;
  MetadataT &operator=(MetadataT o) FLATBUFFERS_NOEXCEPT;
};

struct Metadata FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MetadataT NativeTableType;
  typedef MetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCHEMA_VERSION = 4,
    VT_SUBGRAPHS = 6
  };
  uint32_t schema_version() const {
    return GetField<uint32_t>(VT_SCHEMA_VERSION, 1);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::micro::compression::Subgraph>> *subgraphs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::micro::compression::Subgraph>> *>(VT_SUBGRAPHS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SCHEMA_VERSION, 4) &&
           VerifyOffset(verifier, VT_SUBGRAPHS) &&
           verifier.VerifyVector(subgraphs()) &&
           verifier.VerifyVectorOfTables(subgraphs()) &&
           verifier.EndTable();
  }
  MetadataT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MetadataT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Metadata> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MetadataT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MetadataBuilder {
  typedef Metadata Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_schema_version(uint32_t schema_version) {
    fbb_.AddElement<uint32_t>(Metadata::VT_SCHEMA_VERSION, schema_version, 1);
  }
  void add_subgraphs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::micro::compression::Subgraph>>> subgraphs) {
    fbb_.AddOffset(Metadata::VT_SUBGRAPHS, subgraphs);
  }
  explicit MetadataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Metadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Metadata>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Metadata> CreateMetadata(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t schema_version = 1,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::micro::compression::Subgraph>>> subgraphs = 0) {
  MetadataBuilder builder_(_fbb);
  builder_.add_subgraphs(subgraphs);
  builder_.add_schema_version(schema_version);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Metadata> CreateMetadataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t schema_version = 1,
    const std::vector<::flatbuffers::Offset<tflite::micro::compression::Subgraph>> *subgraphs = nullptr) {
  auto subgraphs__ = subgraphs ? _fbb.CreateVector<::flatbuffers::Offset<tflite::micro::compression::Subgraph>>(*subgraphs) : 0;
  return tflite::micro::compression::CreateMetadata(
      _fbb,
      schema_version,
      subgraphs__);
}

::flatbuffers::Offset<Metadata> CreateMetadata(::flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SubgraphT : public ::flatbuffers::NativeTable {
  typedef Subgraph TableType;
  std::vector<std::unique_ptr<tflite::micro::compression::LutTensorT>> lut_tensors{};
  SubgraphT() = default;
  SubgraphT(const SubgraphT &o);
  SubgraphT(SubgraphT&&) FLATBUFFERS_NOEXCEPT = default;
  SubgraphT &operator=(SubgraphT o) FLATBUFFERS_NOEXCEPT;
};

struct Subgraph FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SubgraphT NativeTableType;
  typedef SubgraphBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LUT_TENSORS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::micro::compression::LutTensor>> *lut_tensors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::micro::compression::LutTensor>> *>(VT_LUT_TENSORS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LUT_TENSORS) &&
           verifier.VerifyVector(lut_tensors()) &&
           verifier.VerifyVectorOfTables(lut_tensors()) &&
           verifier.EndTable();
  }
  SubgraphT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SubgraphT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Subgraph> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SubgraphT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SubgraphBuilder {
  typedef Subgraph Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_lut_tensors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::micro::compression::LutTensor>>> lut_tensors) {
    fbb_.AddOffset(Subgraph::VT_LUT_TENSORS, lut_tensors);
  }
  explicit SubgraphBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Subgraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Subgraph>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Subgraph> CreateSubgraph(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::micro::compression::LutTensor>>> lut_tensors = 0) {
  SubgraphBuilder builder_(_fbb);
  builder_.add_lut_tensors(lut_tensors);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Subgraph> CreateSubgraphDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<tflite::micro::compression::LutTensor>> *lut_tensors = nullptr) {
  auto lut_tensors__ = lut_tensors ? _fbb.CreateVector<::flatbuffers::Offset<tflite::micro::compression::LutTensor>>(*lut_tensors) : 0;
  return tflite::micro::compression::CreateSubgraph(
      _fbb,
      lut_tensors__);
}

::flatbuffers::Offset<Subgraph> CreateSubgraph(::flatbuffers::FlatBufferBuilder &_fbb, const SubgraphT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LutTensorT : public ::flatbuffers::NativeTable {
  typedef LutTensor TableType;
  int32_t tensor = 0;
  uint32_t value_buffer = 0;
  uint8_t index_bitwidth = 0;
};

struct LutTensor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LutTensorT NativeTableType;
  typedef LutTensorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TENSOR = 4,
    VT_VALUE_BUFFER = 6,
    VT_INDEX_BITWIDTH = 8
  };
  int32_t tensor() const {
    return GetField<int32_t>(VT_TENSOR, 0);
  }
  uint32_t value_buffer() const {
    return GetField<uint32_t>(VT_VALUE_BUFFER, 0);
  }
  uint8_t index_bitwidth() const {
    return GetField<uint8_t>(VT_INDEX_BITWIDTH, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TENSOR, 4) &&
           VerifyField<uint32_t>(verifier, VT_VALUE_BUFFER, 4) &&
           VerifyField<uint8_t>(verifier, VT_INDEX_BITWIDTH, 1) &&
           verifier.EndTable();
  }
  LutTensorT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LutTensorT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<LutTensor> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LutTensorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LutTensorBuilder {
  typedef LutTensor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tensor(int32_t tensor) {
    fbb_.AddElement<int32_t>(LutTensor::VT_TENSOR, tensor, 0);
  }
  void add_value_buffer(uint32_t value_buffer) {
    fbb_.AddElement<uint32_t>(LutTensor::VT_VALUE_BUFFER, value_buffer, 0);
  }
  void add_index_bitwidth(uint8_t index_bitwidth) {
    fbb_.AddElement<uint8_t>(LutTensor::VT_INDEX_BITWIDTH, index_bitwidth, 0);
  }
  explicit LutTensorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LutTensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LutTensor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LutTensor> CreateLutTensor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t tensor = 0,
    uint32_t value_buffer = 0,
    uint8_t index_bitwidth = 0) {
  LutTensorBuilder builder_(_fbb);
  builder_.add_value_buffer(value_buffer);
  builder_.add_tensor(tensor);
  builder_.add_index_bitwidth(index_bitwidth);
  return builder_.Finish();
}

::flatbuffers::Offset<LutTensor> CreateLutTensor(::flatbuffers::FlatBufferBuilder &_fbb, const LutTensorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline MetadataT::MetadataT(const MetadataT &o)
      : schema_version(o.schema_version) {
  subgraphs.reserve(o.subgraphs.size());
  for (const auto &subgraphs_ : o.subgraphs) { subgraphs.emplace_back((subgraphs_) ? new tflite::micro::compression::SubgraphT(*subgraphs_) : nullptr); }
}

inline MetadataT &MetadataT::operator=(MetadataT o) FLATBUFFERS_NOEXCEPT {
  std::swap(schema_version, o.schema_version);
  std::swap(subgraphs, o.subgraphs);
  return *this;
}

inline MetadataT *Metadata::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MetadataT>(new MetadataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Metadata::UnPackTo(MetadataT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = schema_version(); _o->schema_version = _e; }
  { auto _e = subgraphs(); if (_e) { _o->subgraphs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->subgraphs[_i]) { _e->Get(_i)->UnPackTo(_o->subgraphs[_i].get(), _resolver); } else { _o->subgraphs[_i] = std::unique_ptr<tflite::micro::compression::SubgraphT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->subgraphs.resize(0); } }
}

inline ::flatbuffers::Offset<Metadata> Metadata::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MetadataT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMetadata(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Metadata> CreateMetadata(::flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MetadataT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _schema_version = _o->schema_version;
  auto _subgraphs = _o->subgraphs.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::micro::compression::Subgraph>> (_o->subgraphs.size(), [](size_t i, _VectorArgs *__va) { return CreateSubgraph(*__va->__fbb, __va->__o->subgraphs[i].get(), __va->__rehasher); }, &_va ) : 0;
  return tflite::micro::compression::CreateMetadata(
      _fbb,
      _schema_version,
      _subgraphs);
}

inline SubgraphT::SubgraphT(const SubgraphT &o) {
  lut_tensors.reserve(o.lut_tensors.size());
  for (const auto &lut_tensors_ : o.lut_tensors) { lut_tensors.emplace_back((lut_tensors_) ? new tflite::micro::compression::LutTensorT(*lut_tensors_) : nullptr); }
}

inline SubgraphT &SubgraphT::operator=(SubgraphT o) FLATBUFFERS_NOEXCEPT {
  std::swap(lut_tensors, o.lut_tensors);
  return *this;
}

inline SubgraphT *Subgraph::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SubgraphT>(new SubgraphT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Subgraph::UnPackTo(SubgraphT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = lut_tensors(); if (_e) { _o->lut_tensors.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->lut_tensors[_i]) { _e->Get(_i)->UnPackTo(_o->lut_tensors[_i].get(), _resolver); } else { _o->lut_tensors[_i] = std::unique_ptr<tflite::micro::compression::LutTensorT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->lut_tensors.resize(0); } }
}

inline ::flatbuffers::Offset<Subgraph> Subgraph::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SubgraphT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSubgraph(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Subgraph> CreateSubgraph(::flatbuffers::FlatBufferBuilder &_fbb, const SubgraphT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SubgraphT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _lut_tensors = _o->lut_tensors.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::micro::compression::LutTensor>> (_o->lut_tensors.size(), [](size_t i, _VectorArgs *__va) { return CreateLutTensor(*__va->__fbb, __va->__o->lut_tensors[i].get(), __va->__rehasher); }, &_va ) : 0;
  return tflite::micro::compression::CreateSubgraph(
      _fbb,
      _lut_tensors);
}

inline LutTensorT *LutTensor::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LutTensorT>(new LutTensorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LutTensor::UnPackTo(LutTensorT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tensor(); _o->tensor = _e; }
  { auto _e = value_buffer(); _o->value_buffer = _e; }
  { auto _e = index_bitwidth(); _o->index_bitwidth = _e; }
}

inline ::flatbuffers::Offset<LutTensor> LutTensor::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LutTensorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLutTensor(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<LutTensor> CreateLutTensor(::flatbuffers::FlatBufferBuilder &_fbb, const LutTensorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LutTensorT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tensor = _o->tensor;
  auto _value_buffer = _o->value_buffer;
  auto _index_bitwidth = _o->index_bitwidth;
  return tflite::micro::compression::CreateLutTensor(
      _fbb,
      _tensor,
      _value_buffer,
      _index_bitwidth);
}

inline const tflite::micro::compression::Metadata *GetMetadata(const void *buf) {
  return ::flatbuffers::GetRoot<tflite::micro::compression::Metadata>(buf);
}

inline const tflite::micro::compression::Metadata *GetSizePrefixedMetadata(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<tflite::micro::compression::Metadata>(buf);
}

inline bool VerifyMetadataBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<tflite::micro::compression::Metadata>(nullptr);
}

inline bool VerifySizePrefixedMetadataBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<tflite::micro::compression::Metadata>(nullptr);
}

inline void FinishMetadataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<tflite::micro::compression::Metadata> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMetadataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<tflite::micro::compression::Metadata> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<tflite::micro::compression::MetadataT> UnPackMetadata(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<tflite::micro::compression::MetadataT>(GetMetadata(buf)->UnPack(res));
}

inline std::unique_ptr<tflite::micro::compression::MetadataT> UnPackSizePrefixedMetadata(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<tflite::micro::compression::MetadataT>(GetSizePrefixedMetadata(buf)->UnPack(res));
}

}  // namespace compression
}  // namespace micro
}  // namespace tflite

#endif  // FLATBUFFERS_GENERATED_METADATA_TFLITE_MICRO_COMPRESSION_H_
