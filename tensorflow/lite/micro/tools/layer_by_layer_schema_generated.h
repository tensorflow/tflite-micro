/* Copyright 2023 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LAYERBYLAYERSCHEMA_H_
#define FLATBUFFERS_GENERATED_LAYERBYLAYERSCHEMA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

struct TensorData;
struct TensorDataBuilder;
struct TensorDataT;

struct SubgraphData;
struct SubgraphDataBuilder;
struct SubgraphDataT;

struct ModelTestData;
struct ModelTestDataBuilder;
struct ModelTestDataT;

enum TensorTypes : int8_t {
  TensorTypes_FLOAT32 = 0,
  TensorTypes_FLOAT16 = 1,
  TensorTypes_INT32 = 2,
  TensorTypes_UINT8 = 3,
  TensorTypes_INT64 = 4,
  TensorTypes_STRING = 5,
  TensorTypes_BOOL = 6,
  TensorTypes_INT16 = 7,
  TensorTypes_COMPLEX64 = 8,
  TensorTypes_INT8 = 9,
  TensorTypes_FLOAT64 = 10,
  TensorTypes_COMPLEX128 = 11,
  TensorTypes_UINT64 = 12,
  TensorTypes_RESOURCE = 13,
  TensorTypes_VARIANT = 14,
  TensorTypes_UINT32 = 15,
  TensorTypes_UINT16 = 16,
  TensorTypes_INT4 = 17,
  TensorTypes_BFLOAT16 = 18,
  TensorTypes_INT2 = 19,
  TensorTypes_MIN = TensorTypes_FLOAT32,
  TensorTypes_MAX = TensorTypes_INT2
};

inline const TensorTypes (&EnumValuesTensorTypes())[20] {
  static const TensorTypes values[] = {
    TensorTypes_FLOAT32,
    TensorTypes_FLOAT16,
    TensorTypes_INT32,
    TensorTypes_UINT8,
    TensorTypes_INT64,
    TensorTypes_STRING,
    TensorTypes_BOOL,
    TensorTypes_INT16,
    TensorTypes_COMPLEX64,
    TensorTypes_INT8,
    TensorTypes_FLOAT64,
    TensorTypes_COMPLEX128,
    TensorTypes_UINT64,
    TensorTypes_RESOURCE,
    TensorTypes_VARIANT,
    TensorTypes_UINT32,
    TensorTypes_UINT16,
    TensorTypes_INT4,
    TensorTypes_BFLOAT16,
    TensorTypes_INT2
  };
  return values;
}

inline const char * const *EnumNamesTensorTypes() {
  static const char * const names[21] = {
    "FLOAT32",
    "FLOAT16",
    "INT32",
    "UINT8",
    "INT64",
    "STRING",
    "BOOL",
    "INT16",
    "COMPLEX64",
    "INT8",
    "FLOAT64",
    "COMPLEX128",
    "UINT64",
    "RESOURCE",
    "VARIANT",
    "UINT32",
    "UINT16",
    "INT4",
    "BFLOAT16",
    "INT2",
    nullptr
  };
  return names;
}

inline const char *EnumNameTensorTypes(TensorTypes e) {
  if (::flatbuffers::IsOutRange(e, TensorTypes_FLOAT32, TensorTypes_INT2)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTensorTypes()[index];
}

struct TensorDataT : public ::flatbuffers::NativeTable {
  typedef TensorData TableType;
  uint32_t input_index = 0;
  uint32_t tensor_index = 0;
  std::vector<int32_t> shape{};
  TensorTypes dtype = TensorTypes_FLOAT32;
  std::vector<uint8_t> data{};
  uint32_t num_bytes = 0;
  uint32_t layer_number = 0;
};

struct TensorData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TensorDataT NativeTableType;
  typedef TensorDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT_INDEX = 4,
    VT_TENSOR_INDEX = 6,
    VT_SHAPE = 8,
    VT_DTYPE = 10,
    VT_DATA = 12,
    VT_NUM_BYTES = 14,
    VT_LAYER_NUMBER = 16
  };
  uint32_t input_index() const {
    return GetField<uint32_t>(VT_INPUT_INDEX, 0);
  }
  uint32_t tensor_index() const {
    return GetField<uint32_t>(VT_TENSOR_INDEX, 0);
  }
  const ::flatbuffers::Vector<int32_t> *shape() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SHAPE);
  }
  TensorTypes dtype() const {
    return static_cast<TensorTypes>(GetField<int8_t>(VT_DTYPE, 0));
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  uint32_t num_bytes() const {
    return GetField<uint32_t>(VT_NUM_BYTES, 0);
  }
  uint32_t layer_number() const {
    return GetField<uint32_t>(VT_LAYER_NUMBER, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_INPUT_INDEX, 4) &&
           VerifyField<uint32_t>(verifier, VT_TENSOR_INDEX, 4) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyField<int8_t>(verifier, VT_DTYPE, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyField<uint32_t>(verifier, VT_NUM_BYTES, 4) &&
           VerifyField<uint32_t>(verifier, VT_LAYER_NUMBER, 4) &&
           verifier.EndTable();
  }
  TensorDataT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorDataT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TensorData> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TensorDataT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorDataBuilder {
  typedef TensorData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_input_index(uint32_t input_index) {
    fbb_.AddElement<uint32_t>(TensorData::VT_INPUT_INDEX, input_index, 0);
  }
  void add_tensor_index(uint32_t tensor_index) {
    fbb_.AddElement<uint32_t>(TensorData::VT_TENSOR_INDEX, tensor_index, 0);
  }
  void add_shape(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape) {
    fbb_.AddOffset(TensorData::VT_SHAPE, shape);
  }
  void add_dtype(TensorTypes dtype) {
    fbb_.AddElement<int8_t>(TensorData::VT_DTYPE, static_cast<int8_t>(dtype), 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(TensorData::VT_DATA, data);
  }
  void add_num_bytes(uint32_t num_bytes) {
    fbb_.AddElement<uint32_t>(TensorData::VT_NUM_BYTES, num_bytes, 0);
  }
  void add_layer_number(uint32_t layer_number) {
    fbb_.AddElement<uint32_t>(TensorData::VT_LAYER_NUMBER, layer_number, 0);
  }
  explicit TensorDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TensorData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TensorData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TensorData> CreateTensorData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t input_index = 0,
    uint32_t tensor_index = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape = 0,
    TensorTypes dtype = TensorTypes_FLOAT32,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0,
    uint32_t num_bytes = 0,
    uint32_t layer_number = 0) {
  TensorDataBuilder builder_(_fbb);
  builder_.add_layer_number(layer_number);
  builder_.add_num_bytes(num_bytes);
  builder_.add_data(data);
  builder_.add_shape(shape);
  builder_.add_tensor_index(tensor_index);
  builder_.add_input_index(input_index);
  builder_.add_dtype(dtype);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TensorData> CreateTensorDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t input_index = 0,
    uint32_t tensor_index = 0,
    const std::vector<int32_t> *shape = nullptr,
    TensorTypes dtype = TensorTypes_FLOAT32,
    const std::vector<uint8_t> *data = nullptr,
    uint32_t num_bytes = 0,
    uint32_t layer_number = 0) {
  auto shape__ = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return CreateTensorData(
      _fbb,
      input_index,
      tensor_index,
      shape__,
      dtype,
      data__,
      num_bytes,
      layer_number);
}

::flatbuffers::Offset<TensorData> CreateTensorData(::flatbuffers::FlatBufferBuilder &_fbb, const TensorDataT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SubgraphDataT : public ::flatbuffers::NativeTable {
  typedef SubgraphData TableType;
  std::vector<std::unique_ptr<TensorDataT>> outputs{};
  uint32_t subgraph_index = 0;
  SubgraphDataT() = default;
  SubgraphDataT(const SubgraphDataT &o);
  SubgraphDataT(SubgraphDataT&&) FLATBUFFERS_NOEXCEPT = default;
  SubgraphDataT &operator=(SubgraphDataT o) FLATBUFFERS_NOEXCEPT;
};

struct SubgraphData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SubgraphDataT NativeTableType;
  typedef SubgraphDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUTS = 4,
    VT_SUBGRAPH_INDEX = 6
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<TensorData>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<TensorData>> *>(VT_OUTPUTS);
  }
  uint32_t subgraph_index() const {
    return GetField<uint32_t>(VT_SUBGRAPH_INDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfTables(outputs()) &&
           VerifyField<uint32_t>(verifier, VT_SUBGRAPH_INDEX, 4) &&
           verifier.EndTable();
  }
  SubgraphDataT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SubgraphDataT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SubgraphData> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SubgraphDataT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SubgraphDataBuilder {
  typedef SubgraphData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<TensorData>>> outputs) {
    fbb_.AddOffset(SubgraphData::VT_OUTPUTS, outputs);
  }
  void add_subgraph_index(uint32_t subgraph_index) {
    fbb_.AddElement<uint32_t>(SubgraphData::VT_SUBGRAPH_INDEX, subgraph_index, 0);
  }
  explicit SubgraphDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SubgraphData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SubgraphData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SubgraphData> CreateSubgraphData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<TensorData>>> outputs = 0,
    uint32_t subgraph_index = 0) {
  SubgraphDataBuilder builder_(_fbb);
  builder_.add_subgraph_index(subgraph_index);
  builder_.add_outputs(outputs);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SubgraphData> CreateSubgraphDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<TensorData>> *outputs = nullptr,
    uint32_t subgraph_index = 0) {
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<TensorData>>(*outputs) : 0;
  return CreateSubgraphData(
      _fbb,
      outputs__,
      subgraph_index);
}

::flatbuffers::Offset<SubgraphData> CreateSubgraphData(::flatbuffers::FlatBufferBuilder &_fbb, const SubgraphDataT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ModelTestDataT : public ::flatbuffers::NativeTable {
  typedef ModelTestData TableType;
  std::vector<std::unique_ptr<TensorDataT>> input_data{};
  std::vector<std::unique_ptr<SubgraphDataT>> subgraph_data{};
  ModelTestDataT() = default;
  ModelTestDataT(const ModelTestDataT &o);
  ModelTestDataT(ModelTestDataT&&) FLATBUFFERS_NOEXCEPT = default;
  ModelTestDataT &operator=(ModelTestDataT o) FLATBUFFERS_NOEXCEPT;
};

struct ModelTestData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ModelTestDataT NativeTableType;
  typedef ModelTestDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT_DATA = 4,
    VT_SUBGRAPH_DATA = 6
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<TensorData>> *input_data() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<TensorData>> *>(VT_INPUT_DATA);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<SubgraphData>> *subgraph_data() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<SubgraphData>> *>(VT_SUBGRAPH_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT_DATA) &&
           verifier.VerifyVector(input_data()) &&
           verifier.VerifyVectorOfTables(input_data()) &&
           VerifyOffset(verifier, VT_SUBGRAPH_DATA) &&
           verifier.VerifyVector(subgraph_data()) &&
           verifier.VerifyVectorOfTables(subgraph_data()) &&
           verifier.EndTable();
  }
  ModelTestDataT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ModelTestDataT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ModelTestData> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ModelTestDataT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ModelTestDataBuilder {
  typedef ModelTestData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_input_data(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<TensorData>>> input_data) {
    fbb_.AddOffset(ModelTestData::VT_INPUT_DATA, input_data);
  }
  void add_subgraph_data(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<SubgraphData>>> subgraph_data) {
    fbb_.AddOffset(ModelTestData::VT_SUBGRAPH_DATA, subgraph_data);
  }
  explicit ModelTestDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ModelTestData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ModelTestData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ModelTestData> CreateModelTestData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<TensorData>>> input_data = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<SubgraphData>>> subgraph_data = 0) {
  ModelTestDataBuilder builder_(_fbb);
  builder_.add_subgraph_data(subgraph_data);
  builder_.add_input_data(input_data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ModelTestData> CreateModelTestDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<TensorData>> *input_data = nullptr,
    const std::vector<::flatbuffers::Offset<SubgraphData>> *subgraph_data = nullptr) {
  auto input_data__ = input_data ? _fbb.CreateVector<::flatbuffers::Offset<TensorData>>(*input_data) : 0;
  auto subgraph_data__ = subgraph_data ? _fbb.CreateVector<::flatbuffers::Offset<SubgraphData>>(*subgraph_data) : 0;
  return CreateModelTestData(
      _fbb,
      input_data__,
      subgraph_data__);
}

::flatbuffers::Offset<ModelTestData> CreateModelTestData(::flatbuffers::FlatBufferBuilder &_fbb, const ModelTestDataT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TensorDataT *TensorData::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TensorDataT>(new TensorDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TensorData::UnPackTo(TensorDataT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = input_index(); _o->input_index = _e; }
  { auto _e = tensor_index(); _o->tensor_index = _e; }
  { auto _e = shape(); if (_e) { _o->shape.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shape[_i] = _e->Get(_i); } } else { _o->shape.resize(0); } }
  { auto _e = dtype(); _o->dtype = _e; }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
  { auto _e = num_bytes(); _o->num_bytes = _e; }
  { auto _e = layer_number(); _o->layer_number = _e; }
}

inline ::flatbuffers::Offset<TensorData> TensorData::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TensorDataT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorData(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TensorData> CreateTensorData(::flatbuffers::FlatBufferBuilder &_fbb, const TensorDataT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TensorDataT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _input_index = _o->input_index;
  auto _tensor_index = _o->tensor_index;
  auto _shape = _o->shape.size() ? _fbb.CreateVector(_o->shape) : 0;
  auto _dtype = _o->dtype;
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  auto _num_bytes = _o->num_bytes;
  auto _layer_number = _o->layer_number;
  return CreateTensorData(
      _fbb,
      _input_index,
      _tensor_index,
      _shape,
      _dtype,
      _data,
      _num_bytes,
      _layer_number);
}

inline SubgraphDataT::SubgraphDataT(const SubgraphDataT &o)
      : subgraph_index(o.subgraph_index) {
  outputs.reserve(o.outputs.size());
  for (const auto &outputs_ : o.outputs) { outputs.emplace_back((outputs_) ? new TensorDataT(*outputs_) : nullptr); }
}

inline SubgraphDataT &SubgraphDataT::operator=(SubgraphDataT o) FLATBUFFERS_NOEXCEPT {
  std::swap(outputs, o.outputs);
  std::swap(subgraph_index, o.subgraph_index);
  return *this;
}

inline SubgraphDataT *SubgraphData::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SubgraphDataT>(new SubgraphDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SubgraphData::UnPackTo(SubgraphDataT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->outputs[_i]) { _e->Get(_i)->UnPackTo(_o->outputs[_i].get(), _resolver); } else { _o->outputs[_i] = std::unique_ptr<TensorDataT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->outputs.resize(0); } }
  { auto _e = subgraph_index(); _o->subgraph_index = _e; }
}

inline ::flatbuffers::Offset<SubgraphData> SubgraphData::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SubgraphDataT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSubgraphData(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SubgraphData> CreateSubgraphData(::flatbuffers::FlatBufferBuilder &_fbb, const SubgraphDataT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SubgraphDataT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _outputs = _o->outputs.size() ? _fbb.CreateVector<::flatbuffers::Offset<TensorData>> (_o->outputs.size(), [](size_t i, _VectorArgs *__va) { return CreateTensorData(*__va->__fbb, __va->__o->outputs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _subgraph_index = _o->subgraph_index;
  return CreateSubgraphData(
      _fbb,
      _outputs,
      _subgraph_index);
}

inline ModelTestDataT::ModelTestDataT(const ModelTestDataT &o) {
  input_data.reserve(o.input_data.size());
  for (const auto &input_data_ : o.input_data) { input_data.emplace_back((input_data_) ? new TensorDataT(*input_data_) : nullptr); }
  subgraph_data.reserve(o.subgraph_data.size());
  for (const auto &subgraph_data_ : o.subgraph_data) { subgraph_data.emplace_back((subgraph_data_) ? new SubgraphDataT(*subgraph_data_) : nullptr); }
}

inline ModelTestDataT &ModelTestDataT::operator=(ModelTestDataT o) FLATBUFFERS_NOEXCEPT {
  std::swap(input_data, o.input_data);
  std::swap(subgraph_data, o.subgraph_data);
  return *this;
}

inline ModelTestDataT *ModelTestData::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ModelTestDataT>(new ModelTestDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ModelTestData::UnPackTo(ModelTestDataT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = input_data(); if (_e) { _o->input_data.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->input_data[_i]) { _e->Get(_i)->UnPackTo(_o->input_data[_i].get(), _resolver); } else { _o->input_data[_i] = std::unique_ptr<TensorDataT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->input_data.resize(0); } }
  { auto _e = subgraph_data(); if (_e) { _o->subgraph_data.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->subgraph_data[_i]) { _e->Get(_i)->UnPackTo(_o->subgraph_data[_i].get(), _resolver); } else { _o->subgraph_data[_i] = std::unique_ptr<SubgraphDataT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->subgraph_data.resize(0); } }
}

inline ::flatbuffers::Offset<ModelTestData> ModelTestData::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ModelTestDataT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateModelTestData(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ModelTestData> CreateModelTestData(::flatbuffers::FlatBufferBuilder &_fbb, const ModelTestDataT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ModelTestDataT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _input_data = _o->input_data.size() ? _fbb.CreateVector<::flatbuffers::Offset<TensorData>> (_o->input_data.size(), [](size_t i, _VectorArgs *__va) { return CreateTensorData(*__va->__fbb, __va->__o->input_data[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _subgraph_data = _o->subgraph_data.size() ? _fbb.CreateVector<::flatbuffers::Offset<SubgraphData>> (_o->subgraph_data.size(), [](size_t i, _VectorArgs *__va) { return CreateSubgraphData(*__va->__fbb, __va->__o->subgraph_data[i].get(), __va->__rehasher); }, &_va ) : 0;
  return CreateModelTestData(
      _fbb,
      _input_data,
      _subgraph_data);
}

inline const ModelTestData *GetModelTestData(const void *buf) {
  return ::flatbuffers::GetRoot<ModelTestData>(buf);
}

inline const ModelTestData *GetSizePrefixedModelTestData(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<ModelTestData>(buf);
}

inline bool VerifyModelTestDataBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ModelTestData>(nullptr);
}

inline bool VerifySizePrefixedModelTestDataBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ModelTestData>(nullptr);
}

inline void FinishModelTestDataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ModelTestData> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedModelTestDataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ModelTestData> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<ModelTestDataT> UnPackModelTestData(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ModelTestDataT>(GetModelTestData(buf)->UnPack(res));
}

inline std::unique_ptr<ModelTestDataT> UnPackSizePrefixedModelTestData(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ModelTestDataT>(GetSizePrefixedModelTestData(buf)->UnPack(res));
}

#endif  // FLATBUFFERS_GENERATED_LAYERBYLAYERSCHEMA_H_
